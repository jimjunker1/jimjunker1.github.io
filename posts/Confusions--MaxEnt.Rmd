---
title: "Confusion:MaxEnt"
date: "`r format(Sys.time(), '%d %B, %Y')`"
layout: collection
# knit: (function(inputFile, encoding){
#        rmarkdown::render(inputFile,
#        encoding=encoding)})
categories:
  - Miscellaneous
tags:
  - content
output:
  md_document:
    preserve_yaml: TRUE
    variant: markdown_strict 
---

This is a post I have been thinking about for a long time and finally am getting around to writing up. The problem was inspired by data on deep sea bivalves and their ecological function of consuming large particulate organic matter, such as tree and logs, on the ocean floor. We wanted to understand how diversity of bivalves influenced the decomposition rate of logs--were biodiversity effects additive or interactive? Does the addition of a new species increase/decrease the decomposition of logs above and beyond the predicted effects of simply adding another individual?

At first, this seemed like a great opportunity to employ [the Price equation](https://winfreelab.com/wp-content/uploads/2022/06/harrison2022_AmNat.pdf), a framework that I had been interested in applying to ecological questions of biodiversity--ecosystem function (I plan to do a more thorough post on the Price equation in the future for a different approach). However, this data set presented a number of issues, some of which were hurdles:

1) we only had abundance of each species on each log,

2) we only had the total mass loss of each log,

3) we lacked other information on these species (e.g., body size, metabolic rates).

As such, we didn't have a clear way to estimate the per-capita effect of any one species. Other aspects of the data represented opportunities to potentially overcome these hurdles, specifically, there were a few logs that only had a single species present. Others had two species in unique combinations. Others were much more diverse with upwards of 8-10 species. 

I thought this was a fun opportunity to think about ways to use the information we had across all the sample logs, particularly the constraints on total mass loss and leveraging the single and dual species examples, to develop a framework for inferring per-capita functions for all species and estimates of species-species interactions. If we have information on the per-capita consumption of a couple species from logs with only a single species, can we use that to inform what their expected per-capita function is in other samples? With information on only one or two species, can we then estimate the expected function of all species across all communities given the constrains on total community function and good estimates for only a subset of the community? 

For this exercise, I made a few assumptions:

1) only bivalves contribute to mass loss. The contribution from other groups (i.e. bacteria, fungi) are negligible

2) total resource consumption over the timespan of the experiment does not lead to resource depletion that alters the function of any bivalve species. This is an assumption that I will relax later.

3) per-capita function in single species samples is not depressed by intraspecific density dependence.

To test some approaches, first I want to simulate some data with known values. For the first simulation, I want to see if I can recover the metabolic rates in communities that are strictly additive, meaning while each species has a unique and fixed per-capita function, there are no interactions among species. Here, the total function of community $j$, $F_{j}$, is just the summed per-capita function, $f_{i}$, of individuals of a species, $N_{i}$, summed across all species, $S$, as:

$$F_{j} = \sum_{i = 1}^{S} N_{ij} f_{i}$$

For this simulation I am going to 1) make up some per-capita function values for ten species, 2) create random communities some of which have only a single species, 3) calculate the total function in each community, 4) using just species abundances and total function from all communities build a model to recapture the species-specific metabolic rates. To do this, I will leverage the [`mobsim` package](https://cran.r-project.org/web/packages/mobsim/vignettes/Simulating_communities.html#simulating-species-abundance-distributions) and the `sim_sad()` function.

```{r comm simulation}
library(mobsim)
library(dplyr)
library(tidyr)
library(purrr)
# set the seed for reproducibility
set.seed(1312)

# create some fake function rates 
metDf = data.frame(
  sp = letters[1:10],
  fi = 10:1
)

# create some random total abundances
abunVec = round(runif(10, 1e2,1e3))

# set the first three communities as random single species
commDf = data.frame(comm = c("c1","c2","c3"),
                    sp = c(sample(letters[1:10],1),
                           sample(letters[1:10],1),
                           sample(letters[1:10],1)),
                    abun = abunVec[1:3]
                           )

# simulate seven other mixed species communities and elongate to combine above
abunList = map(abunVec[4:10],
               ~sim_sad(s_pool = NULL,
                        n_sim = NULL,
                        sad_type = 'bs',
                        sad_coef = list("N" = .x, "S" = 10))
               ) %>% 
  bind_rows(.id = "comm") %>% 
  data.frame %>% 
  dplyr::mutate(comm = stringr::str_c("c",as.numeric(comm)+3)) %>% 
  pivot_longer(cols = -comm, names_to = "sp", values_to = "abun") %>% 
  
  

```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

maxent <- function(A, b) {
  # A: design matrix where each row is a constraint and each column corresponds to a species
  # b: target values for the constraints (e.g., total metabolic rates)
  
  # Define the objective function (negative entropy)
  # x are the metabolic rates we're trying to estimate
  objective_function <- function(x) {
    # Ensure x is non-negative
    x <- pmax(x, 1e-10)
    
    # Calculate negative entropy
    entropy <- sum(x * log(x))
    
    # Penalize based on the constraints (Ax = b)
    penalty <- sum((A %*% x - b)^2)
    
    # Return the sum of negative entropy and the penalty
    return(entropy + penalty)
  }
  
  # Initial guess for the species' metabolic rates
  init_guess <- rep(1, ncol(A))
  
  # Use optim to minimize the objective function
  result <- optim(init_guess, objective_function, method = "L-BFGS-B", lower = 1e-10)
  
  # Return the estimated metabolic rates
  return(result$par)
}

# Example usage:

# Suppose we have a simple case with 3 communities and 2 species
A <- matrix(c(
  0.5, 0.5,
  0.3, 0.7,
  0.6, 0.4
), nrow = 3, byrow = TRUE)
# 
# # Target values for the communities (e.g., total metabolic rates)
b <- c(100, 70, 80)
# 
# # Estimate the most likely metabolic rates for the two species
estimated_metabolic_rates <- maxent(A, b)
# 
# # Print the results
# cat("Estimated Metabolic Rates for Species 1 and 2:\n")
# print(estimated_metabolic_rates)

```

Setting up the problem. 

-Ecological inference problem

```{r init}

# Define the constraints
total_metabolic_rate <- 100  # Total ecosystem metabolic rate
species_proportions <- c(0.4, 0.6)  # Proportions of metabolic rates for species 1 and 2

# Define the number of species
n_species <- length(species_proportions)
```


# Set up the maximum entropy problem
# The constraints are the total metabolic rate and the species proportions
# We seek the most likely distribution of individual metabolic rates given these constraints

```{r}
# Set up the target (expected) values for each constraint
target_values <- c(total_metabolic_rate * species_proportions, total_metabolic_rate)

# Define the design matrix
# The first n_species columns correspond to individual species' contributions
# The last column ensures the total sums to total_metabolic_rate
A <- rbind(diag(n_species), rep(1, n_species))
```

```{r}
# Apply the maxent function to solve for the most likely distribution
result <- maxent(A, target_values)

# # Extract the inferred metabolic rates for each species
inferred_metabolic_rates <- result

```

```{r}
# Print the results
cat("Inferred Metabolic Rates for Species 1 and 2:\n")
print(inferred_metabolic_rates)
cat("Sum of inferred metabolic rates (should equal total metabolic rate):\n")
print(sum(inferred_metabolic_rates))
```


#### example 2 ---

```{r}
# Assume you have 10 communities and 5 species
# The community data matrix includes the relative abundances of species
community_data <- matrix(c(
  0.5, 0.5, 0.0, 0.0, 0.0,  # Community 1
  0.3, 0.7, 0.0, 0.0, 0.0,  # Community 2
  0.0, 0.6, 0.4, 0.0, 0.0,  # Community 3
  0.0, 0.0, 0.5, 0.5, 0.0,  # Community 4
  0.2, 0.2, 0.3, 0.3, 0.0,  # Community 5
  0.1, 0.0, 0.0, 0.6, 0.3,  # Community 6
  0.0, 0.0, 0.0, 0.7, 0.3,  # Community 7
  0.4, 0.0, 0.3, 0.3, 0.0,  # Community 8
  0.0, 0.0, 0.0, 0.0, 1.0,  # Community 9
  0.2, 0.3, 0.1, 0.3, 0.1   # Community 10
), nrow = 10, byrow = TRUE)

# Define the total abundance for each community
total_abundance <- c(200, 100, 150, 200, 120, 80, 90, 110, 50, 140)

# Define the total metabolic rate for each community (assumed)
total_metabolic_rate <- rlnorm(10, log(20), log(4))

# Adjust the total metabolic rate by the total abundance to get per-capita rates
per_capita_metabolic_rate <- total_metabolic_rate / total_abundance

# Design matrix (same as before, representing relative abundances)
A <- community_data

# Target vector (per-capita metabolic rate for each community)
b <- per_capita_metabolic_rate

# Apply the maximum entropy estimation
result <- maxent(A, b)

r1 =(result[1]*(community_data[,1]*total_abundance))/total_metabolic_rate
r2 = (result[2]*(community_data[,2]*total_abundance))/total_metabolic_rate
test = ((community_data %*% result) * total_abundance)/total_metabolic_rate


# Print the inferred per-capita metabolic rates for the species
cat("Inferred Per-Capita Metabolic Rates for Species 1 to 5:\n")
print(result)

```

```{r}
# Load necessary library
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)

# Example data: 3 communities, 3 species
n <- matrix(c(
  10, 20, 30,   # Community 1
  5,  10, 15,   # Community 2
  15, 25, 10    # Community 3
), nrow = 3, byrow = TRUE)

M <- c(1000, 500, 900)  # Example total metabolic rates for the communities

# Data list for STAN
stan_data <- list(
  K = nrow(n),
  S = ncol(n),
  n = n,
  M = M
)

# STAN model code (as a string)
stan_model_code <- "
data {
  int<lower=1> K;        // Number of communities
  int<lower=1> S;        // Number of species
  matrix[K, S] n;        // Abundance matrix (K x S)
  vector[K] M;           // Observed total metabolic rates for each community
}

parameters {
  vector[S] alpha;              // Baseline metabolic rates for each species
  matrix[S, S] a;               // Interaction terms (S x S matrix)
  real<lower=0> sigma;          // Error standard deviation
}

model {
  vector[K] M_hat;              // Predicted metabolic rates

  // Priors (you may adjust based on prior knowledge)
  alpha ~ normal(0, 1);
  to_vector(a) ~ normal(0, 1);
  sigma ~ normal(0, 1);

  // Likelihood
  for (k in 1:K) {
    M_hat[k] = 0;
    for (i in 1:S) {
      real m_i_k = alpha[i];
      for (j in 1:S) {
        m_i_k += a[i,j] * n[k, j];
      }
      M_hat[k] += m_i_k * n[k, i];
    }
  }
  M ~ normal(M_hat, sigma);
}
"

# Compile the STAN model
stan_model <- stan_model(model_code = stan_model_code)

fit = sampling(stan_model, data = stan_data, 
                         iter = 2000, chains = 4)

# Print results
print(fit)

# Extract the results
stan_results <- extract(fit)

# Posterior distributions for alpha and a (species interaction terms)
alpha_posterior <- stan_results$alpha
a_posterior <- stan_results$a

# Summary of the posterior
summary(fit)
```